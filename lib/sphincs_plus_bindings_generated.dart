// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/sphincsplus/ref/api.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class SphincsPlusBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  SphincsPlusBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  SphincsPlusBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Returns the length of a secret key, in bytes
  int crypto_sign_secretkeybytes() {
    return _crypto_sign_secretkeybytes();
  }

  late final _crypto_sign_secretkeybytesPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLongLong Function()>>(
          'crypto_sign_secretkeybytes');
  late final _crypto_sign_secretkeybytes =
      _crypto_sign_secretkeybytesPtr.asFunction<int Function()>();

  /// Returns the length of a public key, in bytes
  int crypto_sign_publickeybytes() {
    return _crypto_sign_publickeybytes();
  }

  late final _crypto_sign_publickeybytesPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLongLong Function()>>(
          'crypto_sign_publickeybytes');
  late final _crypto_sign_publickeybytes =
      _crypto_sign_publickeybytesPtr.asFunction<int Function()>();

  /// Returns the length of a signature, in bytes
  int crypto_sign_bytes() {
    return _crypto_sign_bytes();
  }

  late final _crypto_sign_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLongLong Function()>>(
          'crypto_sign_bytes');
  late final _crypto_sign_bytes =
      _crypto_sign_bytesPtr.asFunction<int Function()>();

  /// Returns the length of the seed required to generate a key pair, in bytes
  int crypto_sign_seedbytes() {
    return _crypto_sign_seedbytes();
  }

  late final _crypto_sign_seedbytesPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLongLong Function()>>(
          'crypto_sign_seedbytes');
  late final _crypto_sign_seedbytes =
      _crypto_sign_seedbytesPtr.asFunction<int Function()>();

  /// Generates a SPHINCS+ key pair given a seed.
  /// Format sk: [SK_SEED || SK_PRF || PUB_SEED || root]
  /// Format pk: [root || PUB_SEED]
  int crypto_sign_seed_keypair(
    ffi.Pointer<ffi.UnsignedChar> pk,
    ffi.Pointer<ffi.UnsignedChar> sk,
    ffi.Pointer<ffi.UnsignedChar> seed,
  ) {
    return _crypto_sign_seed_keypair(
      pk,
      sk,
      seed,
    );
  }

  late final _crypto_sign_seed_keypairPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>)>>('crypto_sign_seed_keypair');
  late final _crypto_sign_seed_keypair =
      _crypto_sign_seed_keypairPtr.asFunction<
          int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Generates a SPHINCS+ key pair.
  /// Format sk: [SK_SEED || SK_PRF || PUB_SEED || root]
  /// Format pk: [root || PUB_SEED]
  int crypto_sign_keypair(
    ffi.Pointer<ffi.UnsignedChar> pk,
    ffi.Pointer<ffi.UnsignedChar> sk,
  ) {
    return _crypto_sign_keypair(
      pk,
      sk,
    );
  }

  late final _crypto_sign_keypairPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>)>>('crypto_sign_keypair');
  late final _crypto_sign_keypair = _crypto_sign_keypairPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Returns an array containing a detached signature.
  int crypto_sign_signature(
    ffi.Pointer<ffi.Uint8> sig,
    ffi.Pointer<ffi.Size> siglen,
    ffi.Pointer<ffi.Uint8> m,
    int mlen,
    ffi.Pointer<ffi.Uint8> sk,
  ) {
    return _crypto_sign_signature(
      sig,
      siglen,
      m,
      mlen,
      sk,
    );
  }

  late final _crypto_sign_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>)>>('crypto_sign_signature');
  late final _crypto_sign_signature = _crypto_sign_signaturePtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>)>();

  /// Verifies a detached signature and message under a given public key.
  int crypto_sign_verify(
    ffi.Pointer<ffi.Uint8> sig,
    int siglen,
    ffi.Pointer<ffi.Uint8> m,
    int mlen,
    ffi.Pointer<ffi.Uint8> pk,
  ) {
    return _crypto_sign_verify(
      sig,
      siglen,
      m,
      mlen,
      pk,
    );
  }

  late final _crypto_sign_verifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>)>>('crypto_sign_verify');
  late final _crypto_sign_verify = _crypto_sign_verifyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>)>();

  /// Returns an array containing the signature followed by the message.
  int crypto_sign(
    ffi.Pointer<ffi.UnsignedChar> sm,
    ffi.Pointer<ffi.UnsignedLongLong> smlen,
    ffi.Pointer<ffi.UnsignedChar> m,
    int mlen,
    ffi.Pointer<ffi.UnsignedChar> sk,
  ) {
    return _crypto_sign(
      sm,
      smlen,
      m,
      mlen,
      sk,
    );
  }

  late final _crypto_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedLongLong>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.UnsignedChar>)>>('crypto_sign');
  late final _crypto_sign = _crypto_signPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedLongLong>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>)>();

  /// Verifies a given signature-message pair under a given public key.
  int crypto_sign_open(
    ffi.Pointer<ffi.UnsignedChar> m,
    ffi.Pointer<ffi.UnsignedLongLong> mlen,
    ffi.Pointer<ffi.UnsignedChar> sm,
    int smlen,
    ffi.Pointer<ffi.UnsignedChar> pk,
  ) {
    return _crypto_sign_open(
      m,
      mlen,
      sm,
      smlen,
      pk,
    );
  }

  late final _crypto_sign_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedLongLong>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.UnsignedChar>)>>('crypto_sign_open');
  late final _crypto_sign_open = _crypto_sign_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedLongLong>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>)>();
}

const String CRYPTO_ALGNAME = 'SPHINCS+';

const int CRYPTO_SECRETKEYBYTES = 64;

const int CRYPTO_PUBLICKEYBYTES = 32;

const int CRYPTO_BYTES = 17088;

const int CRYPTO_SEEDBYTES = 48;
